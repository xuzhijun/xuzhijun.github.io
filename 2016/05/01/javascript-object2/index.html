<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript 基础 - 对象(二) | 徐记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript 基础 - 对象(二)</h1><a id="logo" href="/.">徐记</a><p class="description">简不单</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript 基础 - 对象(二)</h1><div class="post-meta">May 1, 2016<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h3 id="一，基础知识"><a href="#一，基础知识" class="headerlink" title="一，基础知识"></a>一，基础知识</h3><h5 id="1，new-运算符"><a href="#1，new-运算符" class="headerlink" title="1，new 运算符"></a>1，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">new</a> 运算符</h5><p>使用函数（通常是一个不带 <em>return</em> 的构造函数）来创建一个新对象。</p>
<p>有<strong>两种情况</strong>：</p>
<ol>
<li>函数返回的<strong>是对象</strong>，则新对象接收返回的对象。</li>
<li>函数返回的<strong>不是对象</strong>，则把该函数的 <em>this</em>（上下文）指定给新对象。</li>
</ol>
<a id="more"></a>
<h5 id="2，instanceof-运算符"><a href="#2，instanceof-运算符" class="headerlink" title="2，instanceof 运算符"></a>2，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="external">instanceof</a> 运算符</h5><p><strong>对象</strong> <em>instanceof</em> <strong>构造函数</strong></p>
<p>用来检查<strong>构造函数的 <em>prototype</em></strong> 是否存在于该对象的原型链上。</p>
<h5 id="3，Object-prototype-isPrototypeOf-方法"><a href="#3，Object-prototype-isPrototypeOf-方法" class="headerlink" title="3，Object.prototype.isPrototypeOf() 方法"></a>3，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" rel="external">Object.prototype.isPrototypeOf()</a> 方法</h5><p><strong><em>prototype.isPrototypeOf(object)</em></strong>，检测 <em>prototype</em> 对象 是否在 <em>object</em> 对象的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"bell"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"></span><br><span class="line">person1.isPrototypeOf(person2); <span class="comment">// true</span></span><br><span class="line">person2.isPrototypeOf(person1); <span class="comment">// false</span></span><br><span class="line">Person.isPrototypeOf(person1); <span class="comment">// false</span></span><br><span class="line">Person.prototype.isPrototypeOf(person1); <span class="comment">// true</span></span><br><span class="line">Person.prototype.isPrototypeOf(person2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="4，Object-prototype-constructor-属性"><a href="#4，Object-prototype-constructor-属性" class="headerlink" title="4，Object.prototype.constructor 属性"></a>4，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="external">Object.prototype.constructor</a> 属性</h5><p>每个函数在创建时，被会有一个 <em>prototype</em> 属性，其值是一个包含了不可枚举的 <em>constructor</em> 属性，且属性值为该函数的对象。</p>
<p>在未修改的情况下，对象的 <em>constructor</em> 属性指向其构造函数。</p>
<p><a href="https://www.zhihu.com/question/19951896" target="_blank" rel="external">知乎：JavaScript 中对象的 constructor 属性的作用是什么？</a></p>
<p>反之，如果需要隐藏构造函数的原型对象，可修改实例的 <em>constructor</em> 属性。</p>
<h5 id="5，Object-getPrototypeOf-方法"><a href="#5，Object-getPrototypeOf-方法" class="headerlink" title="5，Object.getPrototypeOf() 方法"></a>5，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="external">Object.getPrototypeOf()</a> 方法</h5><p>返回指定对象的原型，也就是对象内部属性 <em>[[prototype]]</em> 的值。</p>
<p>在 <em>ES5</em> 中，如果参数不是一个对象类型，将抛出一个 <em>TypeError</em> 异常。<br>在 <em>ES6</em> 中，参数被强制转换为 <em>Object</em>。</p>
<h5 id="6，Object-setPrototypeOf-方法"><a href="#6，Object-setPrototypeOf-方法" class="headerlink" title="6，Object.setPrototypeOf() 方法"></a>6，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="external">Object.setPrototypeOf()</a> 方法</h5><p><strong>添加原型链：</strong></p>
<p>通过 <em>Object.getPrototypeOf()</em> 和 <em>Object.setPrototypeOf()</em> 的组合，可以给一个新的原型对象添加完整的原型链：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*** Object.appendChain(@object, @prototype)</span><br><span class="line">*</span><br><span class="line">* Appends the first non-native prototype of a chain to a new prototype.</span><br><span class="line">* 把新的原型对象设置为首个非原生原型对象的原型。</span><br><span class="line">* Returns @object (if it was a primitive value it will transformed into an object).</span><br><span class="line">*</span><br><span class="line">*** Object.appendChain(@object [, "@arg_name_1", "@arg_name_2", "@arg_name_3", "..."], "@function_body")</span><br><span class="line">*** Object.appendChain(@object [, "@arg_name_1, @arg_name_2, @arg_name_3, ..."], "@function_body")</span><br><span class="line">*</span><br><span class="line">* Appends the first non-native prototype of a chain to the native Function.prototype object, then appends a</span><br><span class="line">* new Function(["@arg"(s)], "@function_body") to that chain.</span><br><span class="line">* Returns the function.</span><br><span class="line">*</span><br><span class="line">**/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.appendChain = <span class="function"><span class="keyword">function</span>(<span class="params">oChain, oProto</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object.appendChain - Not enough arguments'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> oProto === <span class="string">'number'</span> || <span class="keyword">typeof</span> oProto === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'second argument to Object.appendChain must be an object or a string'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new oChain.constructor(oChain);把基本类型转换为对象类型</span></span><br><span class="line">  <span class="keyword">var</span> oNewProto = oProto,</span><br><span class="line">      oReturn = o2nd = oLast = oChain <span class="keyword">instanceof</span> <span class="keyword">this</span> ? oChain : <span class="keyword">new</span> oChain.constructor(oChain);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span><br><span class="line">   * 从原型链底层向上推, o2nd存当前对象，o1st存当前对象的原型对象</span><br><span class="line">   * 直到遇到当前对象的原型为 Object.prototype 或 Function.prototype 为止</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> o1st = <span class="keyword">this</span>.getPrototypeOf(o2nd);</span><br><span class="line">    o1st !== <span class="built_in">Object</span>.prototype &amp;&amp; o1st !== <span class="built_in">Function</span>.prototype;</span><br><span class="line">    o1st = <span class="keyword">this</span>.getPrototypeOf(o2nd)</span><br><span class="line">  ) &#123;</span><br><span class="line">    o2nd = o1st;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * 如果第二个参数为字符串：</span><br><span class="line">   * 1，把 原生-函数原型对象 赋值为 新原型对象</span><br><span class="line">   * 2，把 参数字符串 构造成 新函数对象</span><br><span class="line">   * 3，把 参数原对象 设置为 新函数对象的原型对象</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">if</span> (oProto.constructor === <span class="built_in">String</span>) &#123;</span><br><span class="line">    oNewProto = <span class="built_in">Function</span>.prototype;</span><br><span class="line">    oReturn = <span class="built_in">Function</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.setPrototypeOf(oReturn, oLast);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把当前对象的原型对象 设置为 新原型对象</span></span><br><span class="line">  <span class="keyword">this</span>.setPrototypeOf(o2nd, oNewProto);</span><br><span class="line">  <span class="keyword">return</span> oReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二，创建复用对象"><a href="#二，创建复用对象" class="headerlink" title="二，创建复用对象"></a>二，创建复用对象</h3><h4 id="1，工厂模式"><a href="#1，工厂模式" class="headerlink" title="1，工厂模式"></a>1，工厂模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  	alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式没有解决对象识别的问题。</p>
<h4 id="2，构造函数模式"><a href="#2，构造函数模式" class="headerlink" title="2，构造函数模式"></a>2，构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</span><br></pre></td></tr></table></figure>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，<br>这正是构造函数模式胜过工厂模式的地方。</p>
<p><strong>构造函数模式的问题：</strong></p>
<p>构造函数中的方法都会在实例上重新创建一遍，不同实例上的同名函数实际上是不相等的。</p>
<h4 id="3，原型模式"><a href="#3，原型模式" class="headerlink" title="3，原型模式"></a>3，原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Nicholas'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">'Software Engineer'</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// Nicholas</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>函数的 <em>prototype</em> 属性指向函数的原型对象，其中包含了所有可以共享给实例的属性和方法。<br>实例被创建后，其内部属性 <em>[[prototype]]</em> 会指向该原型对象。</p>
<p><strong>用对象字面量来重写原型对象：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为重写原型对象会丢失原本的 contructor 属性，</span></span><br><span class="line"><span class="comment">// 根据其原本的数据属性，使用 defineProperty 方法重设。</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Person,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span> <span class="comment">// 默认为 false，所以可以省略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>如果在创建实例后，重写构造函数的原型对象，实例的内部属性 <em>[[prototype]]</em> 仍然是指向重写前的原型对象，所以在重写原型对象时请慎重。</p>
<p><strong>原型模式的问题：</strong></p>
<p>原型模式省略了为构造函数传递初始化参数这一环节，导致所有实例在默认情况下都将取得相同的值。</p>
<p>原型中所有属性被实例共享，如果属性值为简单类型，尚可以通过<strong>屏蔽属性</strong>来重定义。</p>
<p>如果属性值为引用属性，例如数组，则会产生数据共享问题，这可能就不是我们的初衷了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'Nicholas'</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">'Software Engineer'</span>,</span><br><span class="line">  friends: [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>], <span class="comment">//这里 friends 属性的值是个数组类型</span></span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'constructor'</span>, &#123;</span><br><span class="line">  value: Person,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends); <span class="comment">// "Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">// "Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="4，混合模式（构造函数-原型模式）"><a href="#4，混合模式（构造函数-原型模式）" class="headerlink" title="4，混合模式（构造函数+原型模式）"></a>4，混合模式（构造函数+原型模式）</h4><p>构造函数用于定义实例属性，支持向构造函数传递参数。</p>
<p>原型模式用于定义方法和共享的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">'Shelby'</span>, <span class="string">'Court'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'Van'</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends); <span class="comment">// "Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">// "Shelby,Court"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">// false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="5，动态原型模式"><a href="#5，动态原型模式" class="headerlink" title="5，动态原型模式"></a>5，动态原型模式</h4><p>把所有信息都封装在了构造函数中，通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 方法，只在方法不存在的情况下，才会添加到原型中。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Greg'</span>, <span class="number">27</span>, <span class="string">'Doctor'</span>);</span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>使用动态原型模式时，不能使用对象字面量重写原型对象，否则会切断现有实例与新原型之间的联系。</p>
<h4 id="6，寄生构造函数模式（工厂-构造函数模式）"><a href="#6，寄生构造函数模式（工厂-构造函数模式）" class="headerlink" title="6，寄生构造函数模式（工厂+构造函数模式）"></a>6，寄生构造函数模式（工厂+构造函数模式）</h4><p>该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>返回的对象与构造函数或者构造函数的原型对象之间没有关系。</p>
<p><strong>用处：</strong></p>
<p>可以在特殊的情况下用来为对象创建构造函数。</p>
<p><del>自定义构造函数 <strong>继承</strong> 内置构造函数：</del></p>
<p><strong>再注意：</strong></p>
<p>其实 <em>SpecialArray</em> 并没有继承只是 <em>Array</em> 的包装，而函数中带了 <em>return</em> 语句，那么 <em>new</em> 也可以不用。</p>
<p>返回的 <em>values</em> 对象仍然是 <em>Array</em> 的一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建数组</span></span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加值</span></span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  values.toPipedString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回数组</span></span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line">colors.toPipedString(); <span class="comment">// "red|blue|green"</span></span><br></pre></td></tr></table></figure>
<h4 id="7，稳妥构造函数模式"><a href="#7，稳妥构造函数模式" class="headerlink" title="7，稳妥构造函数模式"></a>7，稳妥构造函数模式</h4><p>所谓稳妥对象，是指没有公共属性，而且其方法也不引用 <em>this</em> 的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建要返回的对象</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="comment">// 定义私有变量和函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加方法</span></span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line">person1.sayName(); <span class="comment">// Nicholas</span></span><br><span class="line">person1.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>同寄生构造函数模式一样，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://xuzhijun.github.io/2016/05/01/javascript-object2/" data-id="cinwznoj5000iexjc8tfjm3kq" class="article-share-link">分享到</a><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/对象/">对象</a></div><div class="post-nav"><a href="/2016/05/03/javascript-inherits/" class="pre">JavaScript 基础 - 继承</a><a href="/2016/04/29/javascript-object/" class="next">JavaScript 基础 - 对象(一)</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://xuzhijun.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Class/" style="font-size: 15px;">Class</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/对象/" style="font-size: 15px;">对象</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/05/javascript-class/">ECMAScript 2015 - Class</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/javascript-inherits/">JavaScript 基础 - 继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/01/javascript-object2/">JavaScript 基础 - 对象(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/29/javascript-object/">JavaScript 基础 - 对象(一)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">徐记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>