<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ECMAScript 2015 - Class | 徐记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ECMAScript 2015 - Class</h1><a id="logo" href="/.">徐记</a><p class="description">简不单</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ECMAScript 2015 - Class</h1><div class="post-meta">May 5, 2016<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h3 id="一，Class"><a href="#一，Class" class="headerlink" title="一，Class"></a>一，<em>Class</em></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在 <em>ES6</em> 之前，我们可以通过构造函数来生成新的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><em>ES6</em> 引入了 <em>Class</em> 的概念，我们可以通过 <em>Class</em> 关键字更清晰，面向对象的定义类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ES5 中的 构造函数，变成了 ES6 中的构造方法 constructor</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ES5 中定义在构造函数 prototype 上的共享方法，现在可以直接定义在 Class 内部</span></span><br><span class="line">  toString() &#123; <span class="comment">// 类方法前不用写 function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>ES6</em> 中的 <em>Class</em>，只是一个<strong>语法糖</strong>，可以看做是构造函数的另一种写法。</p>
<p><em>Class</em> 也具有 <em>prototype</em> 属性，可以向其添加新方法，同在 <em>Class</em> 内部定义方法的区别在于：</p>
<p>Class 的内部所有定义的方法，都是<strong>不可枚举的（non-enumerable）</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// 返回可枚举自身属性名的数组</span></span><br><span class="line"><span class="comment">// ["toValue"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// 返回自身属性名的数组，包括不可枚举属性。</span></span><br><span class="line"><span class="comment">// ["constructor","toString","toValue"]</span></span><br></pre></td></tr></table></figure>
<h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a><em>constructor</em> 方法</h4><p><em>constructor</em> 方法是 <em>Class</em> 的默认方法，通过 <em>new</em> 命令生成对象实例时，自动调用该方法。</p>
<p>一个 <em>Class</em> 必须有 <em>constructor</em> 方法，如果没有显式定义，一个空的 <em>constructor</em> 方法会被默认添加。</p>
<p><em>constructor</em> 方法默认返回实例对象（即 <em>this</em>），但也可以指定返回另外一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor函数返回一个全新的对象，导致实例对象不是Foo类的实例。</span></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="Class-的实例对象"><a href="#Class-的实例对象" class="headerlink" title="Class 的实例对象"></a><em>Class</em> 的实例对象</h4><p>生成类的实例对象的写法，与 <em>ES5</em> 完全一样，也是使用 <em>new</em> 命令，不加会报错。</p>
<p>实例的属性除非显式定义在 <em>this</em> 对象上，否则都是定义在 <em>Class</em> 的 <em>prototype</em> 上。</p>
<p><em>Class</em> 的所有实例共享一个原型对象，所以可以通过实例的 <em>__proto__</em> 属性为 <em>Class</em> 添加方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.toString(); <span class="comment">// (2, 3)</span></span><br><span class="line">p1.hasOwnProperty(<span class="string">'x'</span>); <span class="comment">// true</span></span><br><span class="line">p1.hasOwnProperty(<span class="string">'y'</span>); <span class="comment">// true</span></span><br><span class="line">p1.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br><span class="line">p1.__proto__.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__ <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 p1.__proto__ 为 Point 添加新共享方法。</span></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'Oops'</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName(); <span class="comment">// "Oops"</span></span><br><span class="line">p2.printName(); <span class="comment">// "Oops"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Point(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">p3.printName(); <span class="comment">// "Oops"</span></span><br></pre></td></tr></table></figure>
<h4 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a><em>Class</em> 表达式</h4><p><em>Class</em> 也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123; <span class="comment">// Me 只在 Class 内部有效，可省略</span></span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line">inst.getClassName() <span class="comment">// Me</span></span><br><span class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure>
<p>采用 <em>Class</em> 表达式，可以写出立即执行的 <em>Class</em>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><em>Class</em> 不存在变量提升，这一点与 <em>function</em> 完全不同，所以必须保证子类在父类之后定义。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>类和模块的内部，默认就是严格模式，所以不需要使用 <em>use strict</em> 指定运行模式。</p>
<h3 id="二，extends"><a href="#二，extends" class="headerlink" title="二，extends"></a>二，<em>extends</em></h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><em>Class</em> 之间可以通过 <em>extends</em> 关键字实现继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123; <span class="comment">// 子类</span></span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(<span class="number">25</span>, <span class="number">8</span>, <span class="string">'green'</span>);</span><br><span class="line"></span><br><span class="line">cp <span class="keyword">instanceof</span> ColorPoint <span class="comment">// true</span></span><br><span class="line">cp <span class="keyword">instanceof</span> Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><p>1，子类必须在 <em>constructor</em> 方法中调用 <em>super</em> 方法，否则新建实例时会报错。<br>这是因为子类没有自己的 <em>this</em> 对象，而是继承父类的 <em>this</em> 对象，然后对其进行加工。</p>
<p>2，如果子类没有定义 <em>constructor</em> 方法，这个方法会被默认添加。<br>也就是说，不管有没有显式定义，任何一个子类都有 <em>constructor</em> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">  <span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3，在子类的构造函数中，只有调用 <em>super</em> 之后，才可以使用 <em>this</em> 关键字，否则会报错。<br>这是因为子类实例的构建，是基于对父类实例加工，只有 <em>super</em> 方法才能返回父类实例。</p>
<h5 id="继承机制"><a href="#继承机制" class="headerlink" title="继承机制"></a>继承机制</h5><p><strong><em>ES5：</em></strong>实质是先创造子类的实例对象 <em>this</em>，然后再将父类的方法添加到 <em>this</em> 上面（<em>Parent.apply(this)</em>）。</p>
<p><strong><em>ES6：</em></strong>实质是先创造父类的实例对象 <em>this</em>（所以必须先调用 <em>super</em> 方法），然后再用子类的构造函数修改 <em>this</em>。</p>
<h4 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和 __proto__ 属性"></a>类的 <em>prototype</em> 属性和 <em>__proto__</em> 属性</h4><p>大多数浏览器的 <em>ES5</em> 实现之中，每一个对象都有 <em>__proto__</em> 属性，指向对应的构造函数的 <em>prototype</em> 属性。<br><em>Class</em> 作为构造函数的语法糖，同时有 <strong><em>prototype</em></strong> 属性和 <strong><em>__proto__</em></strong> 属性，并且同时存在<strong>两条继承链</strong>。</p>
<p>1，子类的 <em>__proto__</em> 属性，表示构造函数的继承，总是指向父类。</p>
<p>2，子类 <em>prototype</em> 属性的 <em>__proto__</em> 属性，表示<strong>共享方法的继承</strong>，总是指向父类的 <em>prototype</em> 属性。<br>（<strong>在 <em>ES5</em> 中，构造函数之间的继承，只有该条继承链</strong>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类B的__proto__属性指向父类A</span></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 子类B的prototype属性(原型对象)的__proto__属性指向父类A的prototype属性(原型对象)</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>类的继承是按照下面的模式实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B的实例继承A的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"><span class="comment">// B继承A的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.__proto__ = A;</span><br></pre></td></tr></table></figure>
<p><strong>这两条继承链，可以这样理解：</strong></p>
<p>作为一个<strong>对象</strong>，<em>Class B</em> 的原型（<em>__proto__</em> 属性）是 <em>Class A</em>；<br>作为一个<strong>构造函数</strong>，<em>Class B</em> 的原型（<em>prototype</em> 属性）是 <em>Class A</em> 的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.prototype = <span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure>
<h4 id="Extends-的继承目标"><a href="#Extends-的继承目标" class="headerlink" title="Extends 的继承目标"></a><em>Extends</em> 的继承目标</h4><p><em>extends</em> 关键字后面可以跟多种类型的值，任意函数都能被继承。</p>
<h5 id="三种特殊情况："><a href="#三种特殊情况：" class="headerlink" title="三种特殊情况："></a>三种特殊情况：</h5><p>1，子类继承 <em>Object</em> 类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><em>Class A</em> 是构造函数 <em>Object</em> 的复制，<em>Class A</em> 的实例就是 <em>Object</em> 的实例。</p>
<p>2，不存在任何继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><em>Class A</em> 作为一个<strong>基类</strong>（即不存在任何继承），就是一个普通函数，所以直接继承 <em>Funciton.prototype</em>。<br><em>Class A</em> 调用后返回一个<strong>空对象</strong>（即 <em>Object</em> 实例），所以 <em>A.prototype.__proto__</em> 指向构造函数 <em>Object</em> 的 <em>prototype</em> 属性。</p>
<p>3，子类继承 null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><em>Class A</em> 也是一个普通函数，所以直接继承 <em>Funciton.prototype</em>。<br><em>Class A</em> 调用后返回的对象不继承任何方法，所以它的 <em>__proto__</em> 指向 <em>Function.prototype</em>，<br>即实质上执行了下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a><em>Object.getPrototypeOf()</em></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="external">Object.getPrototypeOf()</a> 方法可以用来从子类上获取父类。</p>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a><em>super</em> 关键字</h4><p><em>super</em> 关键字，有<strong>两种用法：</strong></p>
<p>1，作为函数调用时，<em>super</em> 代表父类的构造函数。</p>
<p>2，作为对象调用时，<em>super</em> 代表父类。<br>此时 <em>super</em> 即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p>
<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用 <em>super</em> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"MyObject: "</span> + <span class="keyword">super</span>.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.toString(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure>
<h4 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 __proto__ 属性"></a>实例的 <em>__proto__</em> 属性</h4><p>子类实例的 <em>__proto__</em> 属性的 <em>__proto__</em> 属性，指向父类实例的 <em>__proto__</em> 属性。<br>也就是说，子类的原型的原型，是父类的原型。</p>
<p>因此，通过子类实例的 <em>__proto__.__proto__</em> 属性，可以修改父类实例的行为（<strong>慎用</strong>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">p2.__proto__.__proto__.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Ha'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() <span class="comment">// "Ha"</span></span><br></pre></td></tr></table></figure>
<h3 id="三，原生构造函数的继承"><a href="#三，原生构造函数的继承" class="headerlink" title="三，原生构造函数的继承"></a>三，原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。<br><em>ECMAScript</em> 的原生构造函数大致有下面这些。</p>
<p>Boolean(), Number(), String(), Array(), Date(), Function(), RegExp(), Error(), Object()</p>
<p>由于<strong>继承机制的不同</strong>，在<em>ES6</em> 以前，原生构造函数无法被继承（子类无法获得其内部属性）。</p>
<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p><em>ES5</em> 是先创造子类的实例对象 <em>this</em>，再将父类的属性添加到子类上，<br>这里，由于父类的内部属性无法获取，导致无法真正继承原生构造函数。</p>
<p><em>ES6</em> 是先创造父类的实例对象 <em>this</em>，再用子类的构造函数修改 <em>this</em>，<br>使得父类的所有属性都可以继承。</p>
<p>利用 <em>extends</em> 可以继承原生构造函数的特性，可以在原生数据结构的基础上，定义自己的数据结构。</p>
<p><strong>实例一：</strong>带版本功能的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionedArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.history = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  commit() &#123; <span class="comment">// 通过commit方法，将自己的当前状态存入history属性。</span></span><br><span class="line">    <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.slice());</span><br><span class="line">  &#125;</span><br><span class="line">  revert() &#123; <span class="comment">// 通过revert方法，可以撤销当前版本，回到上一个版本。</span></span><br><span class="line">    <span class="keyword">this</span>.splice(<span class="number">0</span>, <span class="keyword">this</span>.length, ...this.history[<span class="keyword">this</span>.history.length - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> VersionedArray();</span><br><span class="line"></span><br><span class="line">x.push(<span class="number">1</span>);</span><br><span class="line">x.push(<span class="number">2</span>);</span><br><span class="line">x <span class="comment">// [1, 2]</span></span><br><span class="line">x.history <span class="comment">// [[]]</span></span><br><span class="line"></span><br><span class="line">x.commit();</span><br><span class="line">x.history <span class="comment">// [[], [1, 2]]</span></span><br><span class="line">x.push(<span class="number">3</span>);</span><br><span class="line">x <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">x.revert();</span><br><span class="line">x <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p><strong>实例二：</strong>自定义Error子类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendableError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(message) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    <span class="keyword">this</span>.stack = (<span class="keyword">new</span> <span class="built_in">Error</span>()).stack;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">ExtendableError</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(m) &#123;</span><br><span class="line">    <span class="keyword">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myerror = <span class="keyword">new</span> MyError(<span class="string">'ll'</span>);</span><br><span class="line">myerror.message <span class="comment">// "ll"</span></span><br><span class="line">myerror <span class="keyword">instanceof</span> <span class="built_in">Error</span> <span class="comment">// true</span></span><br><span class="line">myerror.name <span class="comment">// "MyError"</span></span><br><span class="line">myerror.stack</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//     at MyError.ExtendableError</span></span><br><span class="line"><span class="comment">//     ...</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>继承Object的子类，有一个<a href="http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object" target="_blank" rel="external">行为差异</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewObj</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>(...arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> NewObj(&#123;attr: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.attr === <span class="literal">true</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="四，Class-的取值函数（getter）和存值函数（setter）"><a href="#四，Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="四，Class 的取值函数（getter）和存值函数（setter）"></a>四，<em>Class</em> 的取值函数（<em>getter</em>）和存值函数（<em>setter</em>）</h3><p>在 <em>Class</em> 内部可以使用 <em>get</em> 和 <em>set</em> 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<p>存值函数和取值函数是设置在属性的 descriptor 对象上的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">"html"</span>);</span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="五，Class-的-Generator-方法"><a href="#五，Class-的-Generator-方法" class="headerlink" title="五，Class 的 Generator 方法"></a>五，<em>Class</em> 的 <em>Generator</em> 方法</h3><p>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="keyword">this</span>.args) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<p><em>Generator, yield, Iterator, Symbol</em> 等 <em>ES6</em> 中的技术，会在以后的文章中细说。</p>
<h3 id="六，Class-的静态方法"><a href="#六，Class-的静态方法" class="headerlink" title="六，Class 的静态方法"></a>六，<em>Class</em> 的静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<br><strong>静态方法：</strong>使用 <em>static</em> 关键字可以在类中定义静态方法，该方法可以在类还没有实例化时被调用，但不可以在类实例化后调用。<strong>静态方法经常作为程序的工具函数使用</strong>。</p>
<p>静态方法<strong>不能</strong>在实例中调用，但<strong>可以</strong>被子类继承，<strong>也可以</strong>通过 super 对象调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tripple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> tripple(n) &#123;</span><br><span class="line">    n = n || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiggerTripple</span> <span class="keyword">extends</span> <span class="title">Tripple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> tripple(n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.tripple(n) * <span class="keyword">super</span>.tripple(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Tripple.tripple());          <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(Tripple.tripple(<span class="number">6</span>));         <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(BiggerTripple.tripple(<span class="number">3</span>));   <span class="comment">// 81</span></span><br><span class="line"><span class="keyword">var</span> tp = <span class="keyword">new</span> Tripple();</span><br><span class="line"><span class="built_in">console</span>.log(BiggerTripple.tripple(<span class="number">3</span>));   <span class="comment">// 81（不会受父类被实例化的影响）</span></span><br><span class="line"><span class="built_in">console</span>.log(tp.tripple());               <span class="comment">// 'tp.tripple is not a function'.</span></span><br></pre></td></tr></table></figure>
<h3 id="七，Class-的静态属性和实例属性"><a href="#七，Class-的静态属性和实例属性" class="headerlink" title="七，Class 的静态属性和实例属性"></a>七，<em>Class</em> 的静态属性和实例属性</h3><p><strong>静态属性</strong>指的是 <em>Class</em> 本身的属性，而不是定义在实例对象（<em>this</em>）上的属性。</p>
<p><em>ES6</em> 中，<em>Class</em> 内部只有静态方法，没有静态属性，在 <em>Class</em> 内部定义的属性都是无效的。</p>
<p>只能在 <em>Class</em> 的外部通过 <em>Class.propname</em> 的方式定义。</p>
<p><em>ES7</em> 中，有一个<a href="https://github.com/jeffmo/es-class-fields-and-static-properties" target="_blank" rel="external">关于静态属性的提案</a>，目前 <em>Babel</em> 转码器支持。</p>
<h5 id="类的实例属性"><a href="#类的实例属性" class="headerlink" title="类的实例属性"></a>类的实例属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 中，只能在类的 constructor 方法里定义实例属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES7 中，类的实例属性可以用等式，写入类的定义之中。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者，为了可读性的目的，对于那些在 constructor 里面已经定义的实例属性，新写法允许直接列出。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的静态属性"><a href="#类的静态属性" class="headerlink" title="类的静态属性"></a>类的静态属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 中，只能在类的外部定义静态属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  prop1: <span class="number">2</span> <span class="comment">// 写法一，无效，但不会报错</span></span><br><span class="line">  <span class="keyword">static</span> prop2: <span class="number">2</span> <span class="comment">// 写法二，无效，但不会报错</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop1 <span class="comment">// undefined</span></span><br><span class="line">Foo.prop2 <span class="comment">// undefined</span></span><br><span class="line">Foo.prop3 = <span class="number">1</span>;</span><br><span class="line">Foo.prop3 <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES7 中，只要在实例属性写法前面，加上 static 关键字就可以了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="八，new-target-属性"><a href="#八，new-target-属性" class="headerlink" title="八，new.target 属性"></a>八，<em>new.target</em> 属性</h3><p><em>new</em> 是从构造函数生成实例的命令。<br><em>ES6</em> 为 new 命令引入了一个 <em>new.target</em> 属性，返回 <em>new</em> 命令作用于的那个构造函数。<br>如果构造函数不是通过 <em>new</em> 命令调用的，<em>new.target</em> 会返回 <em>undefined</em>。</p>
<p>在函数外部，使用 <em>new.target</em> 会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在构造函数中调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>);  <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Class 中调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类时，new.target会返回子类。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p><strong>应用：</strong>不能独立使用、必须继承后才能使用的类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="九，Mixin-模式的实现"><a href="#九，Mixin-模式的实现" class="headerlink" title="九，Mixin 模式的实现"></a>九，Mixin 模式的实现</h3><p><em>Mixin</em> 模式指的是，将多个类的接口“混入”（<em>mix in</em>）另一个类。它在 <em>ES6</em> 的实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    copyProperties(Mix, mixin);</span><br><span class="line">    copyProperties(Mix.prototype, mixin.prototype); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123; <span class="comment">// 遍历源对象的自身属性</span></span><br><span class="line">    <span class="keyword">if</span> ( key !== <span class="string">"constructor"</span> <span class="comment">// 属性过滤</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">"prototype"</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">"name"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key); <span class="comment">// 过滤后属性的描述</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, key, desc); <span class="comment">//通过源属性及其描述来定义目标属性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候，只要继承这个 mix 类即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedEdit</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Loggable</span>, <span class="title">Serializable</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="external">阮一峰：ECMAScript 6 入门 - Class</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">MDN：Classes</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://xuzhijun.github.io/2016/05/05/javascript-class/" data-id="ciqf2bes40004jdjcrzezc2r8" class="article-share-link">分享到</a><div class="tags"><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/Class/">Class</a><a href="/tags/ES6/">ES6</a></div><div class="post-nav"><a href="/2016/05/06/javascript-object3/" class="pre">JavaScript 基础 - JavaScript中的标准内置属性</a><a href="/2016/05/03/javascript-inherits/" class="next">JavaScript 基础 - 继承</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://xuzhijun.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/对象/" style="font-size: 15px;">对象</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/flex/" style="font-size: 15px;">flex</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript-基础/" style="font-size: 15px;">JavaScript 基础</a> <a href="/tags/Class/" style="font-size: 15px;">Class</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/CSS3/" style="font-size: 15px;">CSS3</a> <a href="/tags/Array/" style="font-size: 15px;">Array</a> <a href="/tags/继承/" style="font-size: 15px;">继承</a> <a href="/tags/Underscore/" style="font-size: 15px;">Underscore</a> <a href="/tags/Collection/" style="font-size: 15px;">Collection</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/奶爸/" style="font-size: 15px;">奶爸</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/07/css-flex1/">CSS3 - Flexible Box 基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/life-anewfather16/">奶爸笔记（十六）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/life-anewfather15/">奶爸笔记（十五）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/30/life-anewfather14/">奶爸笔记（十四）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/life-anewfather13/">奶爸笔记（十三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/life-anewfather12/">奶爸笔记（十二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/life-anewfather11/">奶爸笔记（十一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/17/life-anewfather10/">奶爸笔记（十）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/life-anewfather9/">奶爸笔记（九）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/16/life-anewfather8/">奶爸笔记（八）</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">徐记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>